/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
module pc(
    input clk,
    input reset,           // reset assincrono
    input pc_write,        // enable para stalls
    input [31:0] next_pc,
    output reg [31:0] pc
);
    always @(posedge clk or posedge reset) begin
        if (reset) pc <= 0;
        else if (pc_write) pc <= next_pc;
    end
endmodule
module if_id_reg(
    input clk, input reset, input if_id_write, input flush,
    input [31:0] instr_in, input [31:0] pc_in,
    output reg [31:0] pc_out, output reg [31:0] instr_out
);
    always @(posedge clk or posedge reset) begin
        if (reset) begin pc_out <= 0; instr_out <= 0; end
        else if (flush) begin pc_out <= 0; instr_out <= 32'h00000013; end
        else if (if_id_write) begin pc_out <= pc_in; instr_out <= instr_in; end
    end
endmodule
module id_ex_reg(
    input clk, input reset, input flush,
    input reg_write_in, input mem_to_reg_in, input mem_read_in,
    input mem_write_in, input alu_src_in, input [1:0] alu_op_in,
    input branch_in, input is_vector_in,  // novo
    input [31:0] pc_in, input [31:0] read_data1_in, input [31:0] read_data2_in,
    input [31:0] imm_in, input [4:0] rs1_in, input [4:0] rs2_in,
    input [4:0] rd_in, input [2:0] funct3_in, input [6:0] funct7_in,
    output reg reg_write_out, output reg mem_to_reg_out, output reg mem_read_out,
    output reg mem_write_out, output reg alu_src_out, output reg [1:0] alu_op_out,
    output reg branch_out, output reg is_vector_out,  // novo
    output reg [31:0] pc_out, output reg [31:0] read_data1_out,
    output reg [31:0] read_data2_out, output reg [31:0] imm_out,
    output reg [4:0] rs1_out, output reg [4:0] rs2_out, output reg [4:0] rd_out,
    output reg [2:0] funct3_out, output reg [6:0] funct7_out
);
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            reg_write_out <= 0; mem_to_reg_out <= 0; mem_read_out <= 0;
            mem_write_out <= 0; alu_src_out <= 0; alu_op_out <= 0;
            branch_out <= 0; is_vector_out <= 0;
            pc_out <= 0; read_data1_out <= 0; read_data2_out <= 0;
            imm_out <= 0; rs1_out <= 0; rs2_out <= 0; rd_out <= 0;
            funct3_out <= 0; funct7_out <= 0;
        end else if (flush) begin
            reg_write_out <= 0; mem_to_reg_out <= 0; mem_read_out <= 0;
            mem_write_out <= 0; alu_src_out <= 0; alu_op_out <= 0;
            branch_out <= 0; is_vector_out <= 0;
            pc_out <= pc_in; read_data1_out <= 0; read_data2_out <= 0;
            imm_out <= 0; rs1_out <= 0; rs2_out <= 0; rd_out <= 0;
            funct3_out <= 0; funct7_out <= 0;
        end else begin
            reg_write_out <= reg_write_in; mem_to_reg_out <= mem_to_reg_in;
            mem_read_out <= mem_read_in; mem_write_out <= mem_write_in;
            alu_src_out <= alu_src_in; alu_op_out <= alu_op_in;
            branch_out <= branch_in; is_vector_out <= is_vector_in;
            pc_out <= pc_in; read_data1_out <= read_data1_in;
            read_data2_out <= read_data2_in; imm_out <= imm_in;
            rs1_out <= rs1_in; rs2_out <= rs2_in; rd_out <= rd_in;
            funct3_out <= funct3_in; funct7_out <= funct7_in;
        end
    end
endmodule
module regfile(
    input clk,
    input reset,
    input we,
    input [4:0] rs1,
    input [4:0] rs2,
    input [31:0] wd,
    input [4:0] rd,
    output [31:0] rd1,
    output [31:0] rd2
);
    reg [31:0] regs [0:31];
    integer i;
    always @(posedge clk or posedge reset) begin
        if (reset) for (i=0; i<32; i=i+1) regs[i] <= 0;
        else if (we && rd != 0) regs[rd] <= wd;
    end
    assign rd1 = (rs1 != 0) ? regs[rs1] : 0;
    assign rd2 = (rs2 != 0) ? regs[rs2] : 0;
endmodule
module ex_mem_reg(
    input clk, 
    input reset,
    // Sinais de controle
    input reg_write_in, 
    input mem_to_reg_in, 
    input mem_read_in, 
    input mem_write_in,
    input branch_in,
    input [31:0] alu_result_in, 
    input [31:0] write_data_in, 
    input [4:0] rd_in,
    input [4:0] rs1_in,
    input [4:0] rs2_in,
    
    output reg reg_write_out, 
    output reg mem_to_reg_out, 
    output reg mem_read_out, 
    output reg mem_write_out,
    output reg branch_out,
    output reg [31:0] alu_result_out,
    output reg [31:0] write_data_out, 
    output reg [4:0] rd_out,
    output reg [4:0] rs1_out,
    output reg [4:0] rs2_out
);
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            reg_write_out <= 0; mem_to_reg_out <= 0; mem_read_out <= 0;
            mem_write_out <= 0; branch_out <= 0;                     
            alu_result_out <= 0; write_data_out <= 0; 
            rd_out <= 0; rs1_out <= 0; rs2_out <= 0;                 
        end else begin
            reg_write_out <= reg_write_in; 
            mem_to_reg_out <= mem_to_reg_in;
            mem_read_out <= mem_read_in; 
            mem_write_out <= mem_write_in;
            branch_out <= branch_in;                                 
            alu_result_out <= alu_result_in; 
            write_data_out <= write_data_in;
            rd_out <= rd_in;
            rs1_out <= rs1_in; rs2_out <= rs2_in;                    
        end
    end
endmodule
module mem_wb_reg(
    input clk, input reset,
    input reg_write_in, input mem_to_reg_in,
    input [31:0] alu_result_in, input [31:0] mem_data_in, input [4:0] rd_in,
    output reg reg_write_out, output reg mem_to_reg_out,
    output reg [31:0] alu_result_out, output reg [31:0] mem_data_out,
    output reg [4:0] rd_out
);
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            reg_write_out <= 0; mem_to_reg_out <= 0;
            alu_result_out <= 0; mem_data_out <= 0; rd_out <= 0;
        end else begin
            reg_write_out <= reg_write_in; mem_to_reg_out <= mem_to_reg_in;
            alu_result_out <= alu_result_in; mem_data_out <= mem_data_in;
            rd_out <= rd_in;
        end
    end
endmodule
module alu_control(
    input [1:0] alu_op,
    input [2:0] funct3,
    input [6:0] funct7,
    input is_vector,
    output reg [5:0] alu_ctrl  // 6 bits agora
);
    always @(*) begin
        if (is_vector) begin
            // Modo vetorial: [5:4]=modo, [3:0]=operação
            case (funct3)
                3'b000: alu_ctrl = 6'b01_0000; // vadd.8
                3'b001: alu_ctrl = 6'b10_0000; // vadd.16
                3'b010: alu_ctrl = 6'b01_0001; // vsub.8
                3'b011: alu_ctrl = 6'b10_0001; // vsub.16
                3'b100: alu_ctrl = 6'b01_0010; // vand.8
                3'b101: alu_ctrl = 6'b10_0010; // vand.16
                3'b110: alu_ctrl = 6'b01_0011; // vor.8
                3'b111: alu_ctrl = 6'b10_0011; // vor.16
                default: alu_ctrl = 6'b00_0000;
            endcase
        end else begin
            // Modo escalar
            alu_ctrl[5:4] = 2'b00; // modo escalar
            case (alu_op)
                2'b00: alu_ctrl[3:0] = 4'b0000; // ADD
                2'b01: alu_ctrl[3:0] = 4'b0001; // SUB
                2'b10: begin
                    case (funct3)
                        3'b000: alu_ctrl[3:0] = (funct7[5]) ? 4'b0001 : 4'b0000;
                        3'b001: alu_ctrl[3:0] = 4'b0101;
                        3'b010: alu_ctrl[3:0] = 4'b0001;
                        3'b011: alu_ctrl[3:0] = 4'b0001;
                        3'b100: alu_ctrl[3:0] = 4'b0100;
                        3'b101: alu_ctrl[3:0] = (funct7[5]) ? 4'b0111 : 4'b0110;
                        3'b110: alu_ctrl[3:0] = 4'b0011;
                        3'b111: alu_ctrl[3:0] = 4'b0010;
                        default: alu_ctrl[3:0] = 4'b0000;
                    endcase
                end
                2'b11: alu_ctrl[3:0] = 4'b1000; // LUI
                default: alu_ctrl[3:0] = 4'b0000;
            endcase
        end
    end
endmodule

module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule

module forwarding_unit(
    input [4:0] ex_rs1,
    input [4:0] ex_rs2,
    input mem_reg_write,
    input [4:0] mem_rd,
    input wb_reg_write,
    input [4:0] wb_rd,
    output reg [1:0] forwardA,
    output reg [1:0] forwardB
);
    always @(*) begin
        forwardA = 2'b00;
        forwardB = 2'b00;
        
        // Forward A
        if (mem_reg_write && mem_rd != 0 && mem_rd == ex_rs1) begin
            forwardA = 2'b10;
        end else if (wb_reg_write && wb_rd != 0 && wb_rd == ex_rs1) begin
            forwardA = 2'b01;
        end
        
        // Forward B
        if (mem_reg_write && mem_rd != 0 && mem_rd == ex_rs2) begin
            forwardB = 2'b10;
        end else if (wb_reg_write && wb_rd != 0 && wb_rd == ex_rs2) begin
            forwardB = 2'b01;
        end
    end
endmodule
module imm_gen(
    input [31:0] instr,    // Instrução completa
    output reg [31:0] imm  // Imediato estendido
);

    always @(*) begin
        case (instr[6:0])  // Baseado no opcode
            // I-type (addi, lw, jalr)
            7'b0010011, 7'b0000011, 7'b1100111: 
                imm = {{20{instr[31]}}, instr[31:20]};
            
            // S-type (sw)
            7'b0100011: 
                imm = {{20{instr[31]}}, instr[31:25], instr[11:7]};
            
            // B-type (beq, bne)
            7'b1100011: 
                imm = {{19{instr[31]}}, instr[31], instr[7], 
                       instr[30:25], instr[11:8], 1'b0};
            
            // U-type (lui)
            7'b0110111: 
                imm = {instr[31:12], 12'b0};
            
            // J-type (jal)
            7'b1101111: 
                imm = {{11{instr[31]}}, instr[31], instr[19:12], 
                       instr[20], instr[30:21], 1'b0};
            
            default: 
                imm = 32'b0;
        endcase
    end

endmodule
module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule


module DIG_ROM_1024X32_InstructionMemory (
    input [9:0] A,
    input sel,
    output reg [31:0] D
);
    reg [31:0] my_rom [0:-1];

    always @ (*) begin
        if (~sel)
            D = 32'hz;
        else if (A > 10'hffffffffffffffff)
            D = 32'h0;
        else
            D = my_rom[A];
    end

    initial begin
    end
endmodule

module control(
    input [6:0] opcode,
    output reg reg_write,
    output reg mem_to_reg,
    output reg mem_read,
    output reg mem_write,
    output reg alu_src,
    output reg [1:0] alu_op,
    output reg branch,
    output reg is_vector
);
    always @(*) begin
        reg_write = 0; mem_to_reg = 0; mem_read = 0;
        mem_write = 0; alu_src = 0; alu_op = 0; 
        branch = 0; is_vector = 0;
        
        case (opcode)
            7'b0110011: begin reg_write = 1; alu_op = 2'b10; end // R-type
            7'b0010011: begin reg_write = 1; alu_src = 1; alu_op = 2'b10; end // I-type
            7'b0000011: begin reg_write = 1; mem_read = 1; mem_to_reg = 1; alu_src = 1; end // LW
            7'b0100011: begin mem_write = 1; alu_src = 1; end // SW
            7'b1100011: begin branch = 1; alu_op = 2'b01; end // Branch
            7'b0110111: begin reg_write = 1; alu_src = 1; alu_op = 2'b11; end // LUI
            7'b0100111: begin reg_write = 1; is_vector = 1; alu_op = 2'b11; end // Vetorial
            default: ; // NOP
        endcase
    end
endmodule
module DIG_RAMAsync
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
  input [(AddrBits-1):0] A,
  input [(Bits-1):0] D,
  input we,
  output [(Bits-1):0] Q
);
  reg [(Bits-1):0] memory[0:((1 << AddrBits) - 1)];

  assign Q = memory[A];

  always @ (we, A, D) begin
    if (we)
      memory[A] <= D;
  end
endmodule

module hazard_unit(
    input [4:0] id_rs1,
    input [4:0] id_rs2,
    input ex_mem_read,
    input [4:0] ex_rd,
    output reg stall
);
    always @(*) begin
        stall = 0;
        if (ex_mem_read && ex_rd != 0) begin
            if (ex_rd == id_rs1 || ex_rd == id_rs2) begin
                stall = 1;
            end
        end
    end
endmodule

module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule


module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule

module alu(
    input [31:0] a,
    input [31:0] b,
    input [5:0] alu_ctrl,  // [5:4]=modo, [3:0]=operação
    output reg [31:0] result,
    output zero
);
    wire [1:0] vec_mode = alu_ctrl[5:4];
    wire [3:0] op = alu_ctrl[3:0];
    reg [7:0] b0,b1,b2,b3;
    reg [15:0] h0,h1;
    
    always @(*) begin
        case (vec_mode)
            2'b00: begin // escalar
                case (op)
                    4'b0000: result = a + b;
                    4'b0001: result = a - b;
                    4'b0010: result = a & b;
                    4'b0011: result = a | b;
                    4'b0100: result = a ^ b;
                    4'b0101: result = a << b[4:0];
                    4'b0110: result = a >> b[4:0];
                    4'b0111: result = $signed(a) >>> b[4:0];
                    4'b1000: result = b; // LUI
                    default: result = 0;
                endcase
            end
            
            2'b01: begin // 4x8 bits
                case (op)
                    4'b0000: begin // vadd.8
                        b0 = a[7:0] + b[7:0];
                        b1 = a[15:8] + b[15:8];
                        b2 = a[23:16] + b[23:16];
                        b3 = a[31:24] + b[31:24];
                        result = {b3, b2, b1, b0};
                    end
                    4'b0001: begin // vsub.8
                        b0 = a[7:0] - b[7:0];
                        b1 = a[15:8] - b[15:8];
                        b2 = a[23:16] - b[23:16];
                        b3 = a[31:24] - b[31:24];
                        result = {b3, b2, b1, b0};
                    end
                    4'b0010: result = a & b; // vand.8
                    4'b0011: result = a | b; // vor.8
                    default: result = 0;
                endcase
            end
            
            2'b10: begin // 2x16 bits
                case (op)
                    4'b0000: begin // vadd.16
                        h0 = a[15:0] + b[15:0];
                        h1 = a[31:16] + b[31:16];
                        result = {h1, h0};
                    end
                    4'b0001: begin // vsub.16
                        h0 = a[15:0] - b[15:0];
                        h1 = a[31:16] - b[31:16];
                        result = {h1, h0};
                    end
                    4'b0010: result = a & b; // vand.16
                    4'b0011: result = a | b; // vor.16
                    default: result = 0;
                endcase
            end
            
            default: result = 0;
        endcase
    end
    
    assign zero = (result == 0);
endmodule
// pipeline_ctrl.v
module pipeline_ctrl(
    input stall,           // Do hazard_unit
    input branch_taken,    // Do estágio EX (branch foi tomado?)
    input jal_taken,       // Do estágio EX (jal foi executado?)
    input jalr_taken,      // Do estágio EX (jalr foi executado?)
    
    // Sinais de controle para o pipeline
    output reg pc_write,     // Para PC: 1=atualiza, 0=congela
    output reg if_id_write,  // Para IF/ID: 1=atualiza, 0=congela
    output reg if_id_flush,  // Para IF/ID: 1=insere NOP (flush)
    output reg id_ex_flush   // Para ID/EX: 1=insere NOP (flush)
);

    // Sinal combinado para jumps/branches
    wire jump_taken;
    assign jump_taken = branch_taken | jal_taken | jalr_taken;
    
    always @(*) begin
        // Valores padrão: tudo normal, pipeline fluindo
        pc_write = 1'b1;
        if_id_write = 1'b1;
        if_id_flush = 1'b0;
        id_ex_flush = 1'b0;
        
        // CASO 1: Stall (Load-Use Hazard)
        if (stall) begin
            // Congela o pipeline
            pc_write = 1'b0;      // PC não atualiza
            if_id_write = 1'b0;   // IF/ID não atualiza
            id_ex_flush = 1'b1;   // Insere NOP em ID/EX (bolha)
        end
        
        // CASO 2: Jump/Branch taken
        else if (jump_taken) begin
            // Descartar instruções erradas no pipeline
            if_id_flush = 1'b1;   // Descarta instrução em IF/ID
            id_ex_flush = 1'b1;   // Descarta instrução em ID/EX
        end
        
        // Se não stall nem jump, mantém valores padrão
    end
    
endmodule

module Finalmente_top_level (
  input CLK,
  input Reset,
  output [31:0] \PC_-_saida ,
  output [31:0] \IM_-_saida ,
  output [31:0] MUX_MEMnotWB,
  output \Reg_Write? , // Se deve escrever no registrador no ciclo dado
  output [31:0] \Saida_RAM_(memoria_dados) ,
  output [31:0] Resultado_ALU
);
  wire s0;
  wire [31:0] s1;
  wire [31:0] \PC_-_saida_temp ;
  wire s2;
  wire s3;
  wire [31:0] \IM_-_saida_temp ;
  wire [31:0] s4;
  wire [31:0] s5;
  wire [9:0] s6;
  wire s7;
  wire s8;
  wire s9;
  wire s10;
  wire s11;
  wire s12;
  wire [1:0] s13;
  wire s14;
  wire s15;
  wire [31:0] s16;
  wire [31:0] s17;
  wire [31:0] s18;
  wire [4:0] s19;
  wire [4:0] s20;
  wire [2:0] s21;
  wire [6:0] s22;
  wire s23;
  wire s24;
  wire s25;
  wire s26;
  wire s27;
  wire [1:0] s28;
  wire s29;
  wire s30;
  wire [31:0] s31;
  wire [31:0] s32;
  wire [31:0] s33;
  wire [31:0] s34;
  wire [4:0] s35;
  wire [4:0] s36;
  wire [4:0] s37;
  wire [2:0] s38;
  wire [6:0] s39;
  wire \Reg_Write?_temp ;
  wire [4:0] s40;
  wire [31:0] MUX_MEMnotWB_temp;
  wire [4:0] s41;
  wire [6:0] s42;
  wire [1:0] s43;
  wire [31:0] s44;
  wire [31:0] s45;
  wire [5:0] s46;
  wire [31:0] Resultado_ALU_temp;
  wire s47;
  wire [31:0] s48;
  wire s49;
  wire s50;
  wire s51;
  wire s52;
  wire [31:0] s53;
  wire [31:0] s54;
  wire [4:0] s55;
  wire [9:0] s56;
  wire [31:0] \Saida_RAM_(memoria_dados)_temp ;
  wire s57;
  wire [31:0] s58;
  wire [31:0] s59;
  wire [4:0] s60;
  wire [4:0] s61;
  wire s62;
  wire s63;
  wire s64;
  wire s65;
  wire [1:0] s66;
  wire [1:0] s67;
  wire [31:0] s68;
  wire [31:0] s69;
  wire [1:0] s70;
  wire [31:0] s71;
  wire [31:0] s72;
  wire [6:0] s73;
  // pc
  pc pc_i0 (
    .clk( CLK ),
    .reset( Reset ),
    .pc_write( s0 ),
    .next_pc( s1 ),
    .pc( \PC_-_saida_temp  )
  );
  // if_id_reg
  if_id_reg if_id_reg_i1 (
    .clk( CLK ),
    .reset( Reset ),
    .if_id_write( s2 ),
    .flush( s3 ),
    .instr_in( \IM_-_saida_temp  ),
    .pc_in( \PC_-_saida_temp  ),
    .pc_out( s4 ),
    .instr_out( s5 )
  );
  // id_ex_reg
  id_ex_reg id_ex_reg_i2 (
    .clk( CLK ),
    .reset( Reset ),
    .flush( s7 ),
    .reg_write_in( s8 ),
    .mem_to_reg_in( s9 ),
    .mem_read_in( s10 ),
    .mem_write_in( s11 ),
    .alu_src_in( s12 ),
    .alu_op_in( s13 ),
    .branch_in( s14 ),
    .is_vector_in( s15 ),
    .pc_in( s4 ),
    .read_data1_in( s16 ),
    .read_data2_in( s17 ),
    .imm_in( s18 ),
    .rs1_in( s19 ),
    .rs2_in( s19 ),
    .rd_in( s20 ),
    .funct3_in( s21 ),
    .funct7_in( s22 ),
    .reg_write_out( s23 ),
    .mem_to_reg_out( s24 ),
    .mem_read_out( s25 ),
    .mem_write_out( s26 ),
    .alu_src_out( s27 ),
    .alu_op_out( s28 ),
    .branch_out( s29 ),
    .is_vector_out( s30 ),
    .pc_out( s31 ),
    .read_data1_out( s32 ),
    .read_data2_out( s33 ),
    .imm_out( s34 ),
    .rs1_out( s35 ),
    .rs2_out( s36 ),
    .rd_out( s37 ),
    .funct3_out( s38 ),
    .funct7_out( s39 )
  );
  // regfile
  regfile regfile_i3 (
    .clk( CLK ),
    .reset( Reset ),
    .we( \Reg_Write?_temp  ),
    .rs1( s19 ),
    .rs2( s40 ),
    .wd( MUX_MEMnotWB_temp ),
    .rd( s41 ),
    .rd1( s16 ),
    .rd2( s17 )
  );
  // ex_mem_reg
  ex_mem_reg ex_mem_reg_i4 (
    .clk( CLK ),
    .reset( Reset ),
    .reg_write_in( s23 ),
    .mem_to_reg_in( s24 ),
    .mem_read_in( s25 ),
    .mem_write_in( s26 ),
    .branch_in( s29 ),
    .alu_result_in( Resultado_ALU_temp ),
    .write_data_in( s48 ),
    .rd_in( s37 ),
    .rs1_in( s35 ),
    .rs2_in( s36 ),
    .reg_write_out( s49 ),
    .mem_to_reg_out( s50 ),
    .mem_read_out( s51 ),
    .mem_write_out( s52 ),
    .alu_result_out( s53 ),
    .write_data_out( s54 ),
    .rd_out( s55 )
  );
  // mem_wb_reg
  mem_wb_reg mem_wb_reg_i5 (
    .clk( CLK ),
    .reset( Reset ),
    .reg_write_in( s49 ),
    .mem_to_reg_in( s50 ),
    .alu_result_in( s53 ),
    .mem_data_in( \Saida_RAM_(memoria_dados)_temp  ),
    .rd_in( s55 ),
    .reg_write_out( \Reg_Write?_temp  ),
    .mem_to_reg_out( s57 ),
    .alu_result_out( s58 ),
    .mem_data_out( s59 ),
    .rd_out( s41 )
  );
  // alu_control
  alu_control alu_control_i6 (
    .alu_op( s28 ),
    .funct3( s38 ),
    .funct7( s39 ),
    .is_vector( s30 ),
    .alu_ctrl( s46 )
  );
  assign s56[1:0] = 2'b0;
  assign s56[9:2] = s53[9:2];
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i7 (
    .sel( s57 ),
    .in_0( s58 ),
    .in_1( s59 ),
    .out( MUX_MEMnotWB_temp )
  );
  // forwarding_unit
  forwarding_unit forwarding_unit_i8 (
    .ex_rs1( s35 ),
    .ex_rs2( s36 ),
    .mem_reg_write( s49 ),
    .mem_rd( s55 ),
    .wb_reg_write( \Reg_Write?_temp  ),
    .wb_rd( s41 ),
    .forwardA( s67 ),
    .forwardB( s66 )
  );
  // imm_gen
  imm_gen imm_gen_i9 (
    .instr( s5 ),
    .imm( s18 )
  );
  // Somador PC+4
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i10 (
    .a( 32'b100 ),
    .b( \PC_-_saida_temp  ),
    .c_i( 1'b0 ),
    .s( s68 )
  );
  // JARL
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i11 (
    .a( s32 ),
    .b( s34 ),
    .c_i( 1'b0 ),
    .s( s72 )
  );
  assign s6 = \PC_-_saida_temp [9:0];
  assign s73 = s5[6:0];
  assign s42 = s5[6:0];
  assign s19 = s5[19:15];
  assign s40 = s5[24:20];
  assign s60 = s5[19:15];
  assign s61 = s5[24:20];
  assign s20 = s5[11:7];
  assign s21 = s5[14:12];
  assign s22 = s5[31:25];
  // Instruction Memory
  DIG_ROM_1024X32_InstructionMemory DIG_ROM_1024X32_InstructionMemory_i12 (
    .A( s6 ),
    .sel( 1'b1 ),
    .D( \IM_-_saida_temp  )
  );
  // control
  control control_i13 (
    .opcode( s42 ),
    .reg_write( s8 ),
    .mem_to_reg( s9 ),
    .mem_read( s10 ),
    .mem_write( s11 ),
    .alu_src( s12 ),
    .alu_op( s43 ),
    .branch( s14 ),
    .is_vector( s15 )
  );
  // Memoria de Dados
  DIG_RAMAsync #(
    .Bits(32),
    .AddrBits(10)
  )
  DIG_RAMAsync_i14 (
    .A( s56 ),
    .D( s54 ),
    .we( s52 ),
    .Q( \Saida_RAM_(memoria_dados)_temp  )
  );
  // hazard_unit
  hazard_unit hazard_unit_i15 (
    .id_rs1( s60 ),
    .id_rs2( s61 ),
    .ex_mem_read( s51 ),
    .ex_rd( s37 ),
    .stall( s62 )
  );
  Mux_4x1_NBits #(
    .Bits(32)
  )
  Mux_4x1_NBits_i16 (
    .sel( s66 ),
    .in_0( s33 ),
    .in_1( MUX_MEMnotWB_temp ),
    .in_2( s53 ),
    .in_3( 32'b0 ),
    .out( s48 )
  );
  Mux_4x1_NBits #(
    .Bits(32)
  )
  Mux_4x1_NBits_i17 (
    .sel( s67 ),
    .in_0( s32 ),
    .in_1( MUX_MEMnotWB_temp ),
    .in_2( s53 ),
    .in_3( 32'b0 ),
    .out( s44 )
  );
  // Branch/JAL
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i18 (
    .a( s18 ),
    .b( s31 ),
    .c_i( 1'b0 ),
    .s( s69 )
  );
  assign s71 = (32'b11111111111111111111111111111110 & s72);
  CompUnsigned #(
    .Bits(7)
  )
  CompUnsigned_i19 (
    .a( s73 ),
    .b( 7'b1101111 ),
    .\= ( s64 )
  );
  CompUnsigned #(
    .Bits(7)
  )
  CompUnsigned_i20 (
    .a( s73 ),
    .b( 7'b1001111 ),
    .\= ( s65 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i21 (
    .sel( s27 ),
    .in_0( s48 ),
    .in_1( s34 ),
    .out( s45 )
  );
  assign s13 = s43[1:0];
  // alu
  alu alu_i22 (
    .a( s44 ),
    .b( s45 ),
    .alu_ctrl( s46 ),
    .result( Resultado_ALU_temp ),
    .zero( s47 )
  );
  assign s63 = ((s38[0] ^ s47) & s29);
  // pipeline_ctrl
  pipeline_ctrl pipeline_ctrl_i23 (
    .stall( s62 ),
    .branch_taken( s63 ),
    .jal_taken( s64 ),
    .jalr_taken( s65 ),
    .pc_write( s0 ),
    .if_id_write( s2 ),
    .if_id_flush( s3 ),
    .id_ex_flush( s7 )
  );
  assign s70[0] = ((s64 | s63) & ~ s65);
  assign s70[1] = s65;
  Mux_4x1_NBits #(
    .Bits(32)
  )
  Mux_4x1_NBits_i24 (
    .sel( s70 ),
    .in_0( s68 ),
    .in_1( s69 ),
    .in_2( s71 ),
    .in_3( 32'b0 ),
    .out( s1 )
  );
  assign \PC_-_saida  = \PC_-_saida_temp ;
  assign \IM_-_saida  = \IM_-_saida_temp ;
  assign MUX_MEMnotWB = MUX_MEMnotWB_temp;
  assign \Reg_Write?  = \Reg_Write?_temp ;
  assign \Saida_RAM_(memoria_dados)  = \Saida_RAM_(memoria_dados)_temp ;
  assign Resultado_ALU = Resultado_ALU_temp;
endmodule
