def intel_hex_line(address, data_bytes):
    """Gera uma linha Intel HEX"""
    byte_count = len(data_bytes)
    
    # Cabeçalho
    line = f":{byte_count:02X}{address:04X}00"
    
    # Dados
    data_sum = byte_count + (address >> 8) + (address & 0xFF)
    for byte in data_bytes:
        line += f"{byte:02X}"
        data_sum += byte
    
    # Checksum
    checksum = (-data_sum) & 0xFF
    line += f"{checksum:02X}"
    
    return line

# Programa em bytes (little-endian)
program_bytes = [
    # 2 instruções por linha (8 bytes)
    [0x93, 0x00, 0x00, 0x00, 0x13, 0x01, 0x10, 0x00],  # 00000093 00100113
    [0x93, 0x00, 0x00, 0x00, 0x13, 0x01, 0x10, 0x00],  # 00000093 00100113
    [0x93, 0x00, 0x00, 0x00, 0x13, 0x01, 0x10, 0x00],  # 00000093 00100113
    [0x93, 0x00, 0x00, 0x00, 0x13, 0x01, 0x10, 0x00],  # 00000093 00100113
    [0xB3, 0x81, 0x20, 0x00, 0x13, 0x01, 0x41, 0x00],  # 002081B3 00410113
    [0xB3, 0x81, 0x20, 0x00, 0x13, 0x01, 0x41, 0x00],  # 002081B3 00410113
    [0x93, 0x01, 0x81, 0x00, 0x13, 0x02, 0xC1, 0x00],  # 00810193 00C10213
    [0xB3, 0x80, 0x40, 0x00, 0x13, 0x00, 0x00, 0x00],  # 004080B3 00000013
    [0x13, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00],  # 00000013 00000013
    [0x33, 0x84, 0x20, 0x00, 0xB3, 0x04, 0x44, 0x00],  # 00208433 004404B3
    [0x13, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00],  # 00000013 00000013
    [0x13, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00],  # 00000013 00000013
]

program_bytes_2 = [
    # === BLOCO 1: Setup inicial (0x00-0x0F) ===
    # 0x00: addi x1, x0, 10     = 0x00A00093
    # 0x04: addi x2, x0, 20     = 0x01400113
    [0x93, 0x00, 0xA0, 0x00, 0x13, 0x01, 0x40, 0x01],
    
    # 0x08: addi x3, x0, 0x100  = 0x10000193
    # 0x0C: addi x4, x0, 0x200  = 0x20000213
    [0x93, 0x01, 0x00, 0x10, 0x13, 0x02, 0x00, 0x20],
    
    # === BLOCO 2: Load/Store Test (0x10-0x1C) ===
    # 0x10: sw x1, 0(x3)        = 0x0011A023
    # 0x14: lw x5, 0(x3)        = 0x0001A283
    [0x23, 0xA0, 0x11, 0x00, 0x83, 0xA2, 0x01, 0x00],
    
    # 0x18: add x6, x5, x2      = 0x005102B3
    # 0x1C: sw x6, 4(x3)        = 0x0061A223
    [0xB3, 0x02, 0x51, 0x00, 0x23, 0xA2, 0x61, 0x00],
    
    # === BLOCO 3: Branch Test (0x20-0x2C) ===
    # 0x20: beq x1, x5, L1(+8)  = 0x00508463
    # 0x24: addi x7, x0, 1      = 0x00100393 (SERÁ PULADO!)
    [0x63, 0x84, 0x50, 0x00, 0x93, 0x03, 0x10, 0x00],
    
    # 0x28: nop (espaço)        = 0x00000013
    # 0x2C: nop                 = 0x00000013
    [0x13, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00],
    
    # === BLOCO 4: Label L1 (0x30-0x3C) ===
    # 0x30: addi x7, x0, 99     = 0x06300393
    # 0x34: bne x1, x2, L2(+16) = 0x02210C63
    [0x93, 0x03, 0x60, 0x06, 0x63, 0x0C, 0x21, 0x02],
    
    # 0x38: addi x8, x0, 2      = 0x00200413 (SERÁ PULADO!)
    # 0x3C: nop                 = 0x00000013
    [0x13, 0x04, 0x20, 0x00, 0x13, 0x00, 0x00, 0x00],
    
    # === BLOCO 5: Label L2 (0x44-0x50) ===
    # 0x44: addi x8, x0, 88     = 0x05800413
    # 0x48: jal x9, L3(+24)     = 0x018004EF
    [0x13, 0x04, 0x80, 0x05, 0xEF, 0x04, 0x80, 0x01],
    
    # === BLOCO 6: Após JAL (0x4C-0x58) ===
    # 0x4C: addi x10, x0, 3     = 0x00300513 (NUNCA EXECUTADA!)
    # 0x50: nop                 = 0x00000013
    [0x13, 0x05, 0x30, 0x00, 0x13, 0x00, 0x00, 0x00],
    
    # === BLOCO 7: Label L3 (0x60-0x64) ===
    # 0x60: addi x10, x0, 77    = 0x04D00513
    # 0x64: jalr x0, 0(x9)      = 0x00048067
    [0x13, 0x05, 0xD0, 0x04, 0x67, 0x80, 0x04, 0x00],
    
    # === BLOCO 8: Após JALR (0x4C-0x58) - execução real ===
    # 0x4C: addi x11, x0, 66    = 0x04200593
    # 0x50: lui x12, 0x12345    = 0x12345637
    [0x93, 0x05, 0x20, 0x04, 0x37, 0x56, 0x34, 0x12],
    
    # === BLOCO 9: Operações Vetoriais (0x58-0x64) ===
    # 0x58: vadd.8 x13, x1, x2  = 0x00D82047 (OPCODE VETORIAL!)
    # 0x5C: vadd.16 x14, x1, x2 = 0x00E83047
    [0x47, 0x20, 0xD8, 0x00, 0x47, 0x30, 0xE8, 0x00],
    
    # === BLOCO 10: Mais vetoriais (0x68-0x74) ===
    # 0x68: vsub.8 x15, x2, x1  = 0x00F12047
    # 0x6C: vand.8 x16, x1, x2  = 0x01024047
    [0x47, 0x20, 0xF1, 0x00, 0x47, 0x40, 0x10, 0x01],
    
    # === BLOCO 11: Operações escalares (0x78-0x84) ===
    # 0x78: and x17, x1, x2     = 0x0120F0B3
    # 0x7C: or x18, x1, x2      = 0x0120E133
    [0xB3, 0xF0, 0x20, 0x01, 0x33, 0xE1, 0x20, 0x01],
    
    # === BLOCO 12: Shifts (0x88-0x94) ===
    # 0x88: sll x19, x1, x2     = 0x012099B3
    # 0x8C: srl x20, x2, x1     = 0x00115D33
    [0xB3, 0x99, 0x20, 0x01, 0x33, 0x5D, 0x11, 0x00],
    
    # === BLOCO 13: Loop (0x98-0xA4) ===
    # 0x98: addi x21, x0, 5     = 0x00500A93
    # 0x9C: LOOP: addi x21, x21, -1 = 0xFFFA8A93
    [0x93, 0x0A, 0x50, 0x00, 0x93, 0x0A, 0xFA, 0xFF],
    
    # 0xA0: bne x21, x0, LOOP(-8) = 0xFE0A9AE3
    # 0xA4: nop                 = 0x00000013
    [0xE3, 0x9A, 0x0A, 0xFE, 0x13, 0x00, 0x00, 0x00],
    
    # === BLOCO 14: Resultados finais (0xA8-0xB4) ===
    # 0xA8: add x22, x7, x8     = 0x00838B33
    # 0xAC: sw x22, 8(x3)       = 0x0161A423
    [0x33, 0x8B, 0x83, 0x00, 0x23, 0xA4, 0x61, 0x01],
    
    # 0xB0: lw x23, 8(x3)       = 0x0081AB83
    # 0xB4: add x24, x23, x10   = 0x00AB8C33
    [0x83, 0xAB, 0x81, 0x00, 0x33, 0x8C, 0xAB, 0x00],
    
    # === BLOCO 15: Nops finais (0xB8-0xC4) ===
    # 0xB8: nop                 = 0x00000013
    # 0xBC: nop                 = 0x00000013
    [0x13, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00],
    
    # 0xC0: nop                 = 0x00000013
    # 0xC4: nop                 = 0x00000013
    [0x13, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00],
]

# Total: 15 blocos × 2 instruções = 30 instruções + 6 nops = 36 instruções


# Gerar HEX
hex_lines = []
for i, bytes_line in enumerate(program_bytes_2):
    address = i * 8  # 0x0, 0x8, 0x10, ...
    hex_lines.append(intel_hex_line(address, bytes_line))

# Linha final
hex_lines.append(":00000001FF")

# Imprimir
for line in hex_lines:
    print(line)
